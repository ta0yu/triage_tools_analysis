# triage_tools_analysis

This repo lists the most frequently used triage tools on Linux.

1. [AFL/AFL++](#afl-id)
2. [exploitable](#exploitable-id)
3. [crashwalk](#crashwalk-id)
4. [afl-utils](#afl-utils-id)
5. [clusterfuzz](#clusterfuzz-id)

## 1. <a name="afl-id"></a>[AFL](https://github.com/google/AFL/tree/master)/[AFL++](https://github.com/AFLplusplus/AFLplusplus)

> no further triage

Path to the triage scripts for AFL and AFL++ are [experimental/crash_triage/triage_crashes.sh](https://github.com/google/AFL/blob/master/experimental/crash_triage/triage_crashes.sh) and [examples/crash_triage/triage_crashes.sh](https://github.com/AFLplusplus/AFLplusplus/blob/stable/examples/crash_triage/triage_crashes.sh), respectively.

AFL/AFL++ consider a crash unique based on **the trace bitmap**. `triage_crashes.sh` doesn't further group the unique crashes identified by AFL/AFL++, it only reproduces the crash, and then prints relavent information, including instruction that causes the crash and instructions near it, backtrace, and register information.

### usage

```
$ <path_to_triage_crashes.sh> <path_to_afl_output_dir_to_tested_binary> <path_to_afl_output_dir_to_tested_binary> [...target params...]
```

## 2. <a name="exploitable-id"></a>[explitable](https://github.com/jfoote/exploitable)

> triage crashes empirically by exploitablity level based on the behavior of crash

The 'exploitable' GDB plugin is only capable of analzing single crash at a time.

[exploitable.py](https://github.com/jfoote/exploitable/blob/master/exploitable/exploitable.py) is the entry point
--> [classifier.py](https://github.com/jfoote/exploitable/blob/master/exploitable/lib/classifier.py) implement the entry to the iteration of all rules, general form of rules and their ranks are implemented in ([rules.py](https://github.com/jfoote/exploitable/blob/master/exploitable/lib/rules.py))
--> for every rule, determine match or not ([analyzer](https://github.com/jfoote/exploitable/tree/master/exploitable/lib/analyzers)/\<specific platform\>.py, e.g [x86.py](https://github.com/jfoote/exploitable/blob/master/exploitable/lib/analyzers/x86.py)) --> the match with highest rank is chosen.

Crashes are triaged based on:

1. SIGNAL (e.g. access violation signal, abort signal...)
2. Location of crash (heap, stack)
3. Instruction (jump, banch...)
4. Operand (destination operand, source operand)
5. Near null or not
6. ...

### usage

```
$ gdb ./sample/objdump  # this objdump is afl instrumented
(gdb) set args -d <path_to_input_file>
(gdb) run
(gdb) source exploitable
(gdb) exploitable
__main__:99: UserWarning: GDB v7.11 may not support required Python API
Description: Abort signal
Short description: AbortSignal (20/22)
Hash: 7ad05bf632a1d1468cdf3b0a3acf958a.815d23ceddc9d7dfdb6af07edbe2e3d0
Exploitability Classification: UNKNOWN
Explanation: The target is stopped on a SIGABRT. SIGABRTs are often generated by libc and compiled check-code to indicate potentially exploitable conditions. Unfortunately this command does not yet further analyze these crashes.
```

## 3. <a name="crashwalk-id"></a>[crashwalk](https://github.com/bnagy/crashwalk)

> wrapper around `exploitable` to support triage for multiple crashes at at a time

It takes a directory of input files that would cause crash, apply `exploitable` to each input file, group crashes with the same backtrace hash, save output to `crashwalk.db`

AFL friendly.

### usage: cwtriage

```
$ <path_to_cwtriage>  -root ./sample/objdump-crash/ -match id -- ./sample/objdump -d @@
2020/09/17 18:21:22 ------
Command: ../binutils-2.26.1/build/binutils/nm-new -C fuzzer01/crashes/id:000000,sig:06,src:002373,op:flip1,pos:91
File: fuzzer01/crashes/id:000000,sig:06,src:002373,op:flip1,pos:91
Memory Limit: -1
Timeout: 60
Error: no crash detected
---------
2020/09/17 18:21:23 ------
Command: ../binutils-2.26.1/build/binutils/nm-new -C fuzzer01/crashes/id:000001,sig:06,src:002373,op:flip2,pos:91
File: fuzzer01/crashes/id:000001,sig:06,src:002373,op:flip2,pos:91
Memory Limit: -1
Timeout: 60
Error: no crash detected
---------
---CRASH SUMMARY---
Filename: fuzzer01/crashes/id:000002,sig:11,src:003004,op:flip8,pos:269
SHA1: b00622aa1b2bea89a008806e6ed4fc1722fb61c7
Classification: EXPLOITABLE
Hash: 7348321780591e5f46bfcd05de990935.1b343c7d0db6dc62a10302444b6f67be
Command: ../binutils-2.26.1/build/binutils/nm-new -C fuzzer01/crashes/id:000002,sig:11,src:003004,op:flip8,pos:269
Faulting Frame:
   bfd_elf_get_elf_syms @ 0x00000000004c5a23: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
Disassembly:
Stack Head (7 entries):
   bfd_elf_get_elf_syms      @ 0x00000000004c5a23: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
   bfd_elf32_slurp_symbol_ta @ 0x0000000000610099: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
   _bfd_elf_canonicalize_sym @ 0x0000000000513523: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
   _bfd_generic_read_minisym @ 0x000000000045c3aa: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
   display_rel_file          @ 0x0000000000408ca3: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
   display_file              @ 0x000000000040c7e6: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
   main                      @ 0x00000000004056e6: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/nm-new
Registers:
rax=0x000000000000ff00 rbx=0x0000000000a35268 rcx=0x00000000007ecc80 rdx=0x0000000000a351b0
rsi=0x0000000000a34428 rdi=0x0000000000a343c0 rbp=0x0000000000a34290 rsp=0x00007fffffffe100
 r8=0x0000000000a35268  r9=0x0000000000000000 r10=0x000000000000000f r11=0x00007ffff79b3b78
r12=0x0000000000000000 r13=0x0000000000a375d0 r14=0x000000000000000f r15=0x0000000000000000
rip=0x00000000004c5a23 efl=0x0000000000010202  cs=0x0000000000000033  ss=0x000000000000002b
 ds=0x0000000000000000  es=0x0000000000000000  fs=0x0000000000000000  gs=0x0000000000000000
Extra Data:
   Description: Access violation on destination operand
   Short description: DestAv (8/22)
   Explanation: The target crashed on an access violation at an address matching the destination operand of the instruction. This likely indicates a write access violation, which means the attacker may control the write address and/or value.
---END SUMMARY---
```

### usage: cwdump

```
$ <path_to_cwdump> ./sample/crashwalk.db
(1 of 142) - Hash: 7ad05bf632a1d1468cdf3b0a3acf958a.815d23ceddc9d7dfdb6af07edbe2e3d0
---CRASH SUMMARY---
Filename: all_crashes_ori/id:000026,sig:06,src:003992+006248,op:splice,rep:128
SHA1: 05f038a234ad6812a114d18038d2c4e1d8f29974
Classification: UNKNOWN
Hash: 7ad05bf632a1d1468cdf3b0a3acf958a.815d23ceddc9d7dfdb6af07edbe2e3d0
Command: ../binutils-2.26.1/build/binutils/objdump -d all_crashes_ori/id:000026,sig:06,src:003992+006248,op:splice,rep:128
Faulting Frame:
   OP_VEX @ 0x0000000000546459: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
Disassembly:
Stack Head (13 entries):
   __GI_raise                @ 0x00007ffff7624438: in (BL)
   __GI_abort                @ 0x00007ffff762603a: in (BL)
   OP_VEX                    @ 0x0000000000546459: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   print_insn                @ 0x0000000000564b0a: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   disassemble_bytes         @ 0x0000000000424442: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   disassemble_section       @ 0x0000000000424442: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   bfd_map_over_sections     @ 0x00000000005b0014: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   disassemble_data          @ 0x0000000000414537: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   dump_bfd                  @ 0x000000000041d870: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   display_object_bfd        @ 0x000000000041f2f0: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   display_any_bfd           @ 0x000000000041f2f0: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   display_file              @ 0x000000000040c5c2: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
   main                      @ 0x000000000040c5c2: in /home/mushroom_afl_01/test_cases/binutils-2.26.1/build/binutils/objdump
Registers:
rax=0x0000000000000000 rbx=0x0000000000000003 rcx=0x00007ffff7624438 rdx=0x0000000000000006
rsi=0x0000000000004051 rdi=0x0000000000004051 rbp=0x0000000000a040a0 rsp=0x00007fffffffdaf8
 r8=0x0000000000000001  r9=0x00000000005461b0 r10=0x0000000000000008 r11=0x0000000000000246
r12=0x0000000000000002 r13=0x0000000000000003 r14=0x0000000000a040b8 r15=0x0000000000c76b84
rip=0x00007ffff7624438 efl=0x0000000000000246  cs=0x0000000000000033  ss=0x000000000000002b
 ds=0x0000000000000000  es=0x0000000000000000  fs=0x0000000000000000  gs=0x0000000000000000
Extra Data:
   Description: Abort signal
   Short description: AbortSignal (20/22)
   Explanation: The target is stopped on a SIGABRT. SIGABRTs are often generated by libc and compiled check-code to indicate potentially exploitable conditions. Unfortunately this command does not yet further analyze these crashes.
---END SUMMARY---
```

## 4. <a name="afl-utils-id"></a>[afl-utils](https://github.com/rc0r/afl-utils)

> **not needed** since crashwalk automatically do crash verification

> make use of `exploitable`, same as `crashwalk`

[`afl-vcrash`](https://github.com/rc0r/afl-utils/blob/master/README.md#afl-vcrash) may be useful, it verifies that afl-fuzz crash samples really lead to crashes in the target binary and optionally removes these samples automatically.

## 5. <a name="clusterfuzz-id"></a>[clusterfuzz](https://github.com/google/clusterfuzz)

> a more comprehensive and flexible triage tool

It covers a wide range of possible crashe senario including crashes happen in different languages, platforms, using different sanitizer and others.

Path to the analysis logic is [src/python/crash_analysis/](https://github.com/google/clusterfuzz/tree/master/src/python/crash_analysis). Main logic is in [stack_parsing/stack_analyzer.py](https://github.com/google/clusterfuzz/blob/master/src/python/crash_analysis/stack_parsing/stack_analyzer.py). Crash analysis and triage module can be used stand-alone, which takes error message as input, and output the analysis of crashes.

The main idea is to compare the error message line by line with empirically delineated regular expression, if match then record the corresponding crash type. The identified crashes are further grouped together based on three criteria which are implemented in [crash_comparer.py](https://github.com/google/clusterfuzz/blob/master/src/python/crash_analysis/crash_comparer.py) to see if unique.

### usage

The example usage of crash analysis can be found in `clusterfuzz_triage_wrapper.py`
